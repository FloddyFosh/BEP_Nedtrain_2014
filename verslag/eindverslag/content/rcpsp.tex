\section{Probleemanalyse}

Het probleem waar NedTrain mee te maken heeft, staat ook wel bekend als het \emph{Resource Constraint Project Scheduling Problem (RCPSP)}. Zo'n probleem gaat om het inplannen van activiteiten die elk bepaalde resources nodig hebben, zonder dat de maximale capaciteit van de resources geschonden wordt. De instanties van NedTrain bestaan uit projecten $P = \{p_1, \dots , p_n\}$ die uit 1 of meer subactiviteiten bestaan. Deze projecten $p_a$ hebben een starttijd \emph{(release time)} $rs_a$ en een deadline $dl_a$. De subactiviteiten van project $p_a$ mogen pas vanaf $rs_a$ uitgevoerd worden, maar moeten wel uiterlijk op $dl_a$ klaar zijn. De b$^e$ activiteit van project $p_a$ wordt weergegeven als $v_{a,b}$. Deze activiteit heeft een tijdsduur van $d_{a,b}$ tijdseenheden.

Er zijn drie soorten voorwaarden \emph{(constraints)} waar rekening mee gehouden moet worden bij het oplossen van RCPSP. Dit zijn tijdsconstraints, voorrangsrelaties (precedence constraints) en resource constraints. De tijdsconstraints zijn de hierboven genoemde starttijden en deadlines van de projecten. Een eventuele voorrangsrelatie $v_{i,j} \prec v_{u,v}$ kan bestaan tussen twee activiteiten $v_{i,j}$ en $v_{u,v}$, waardoor activiteit $v_{i,j}$ voltooid moet zijn, voordat activiteit $v_{u,v}$ uitgevoerd mag worden. Tenslotte zijn oplossingen ook gelimiteerd door de resource constraints. Elke taak kan namelijk van verschillende soorten resources $r_k$ een bepaald aantal units nodig hebben. Het aantal units dat activiteit $v_{i,j}$ van resource $r_k$ nodig heeft, wordt genoteerd als $req(v_{i,j},r_k)$.

Een formele definitie van RCPSP kan nu als volgt opgesteld worden:

\textbf{Gegeven:}\\
Een verzameling projecten $P = \{p_1, \dots ,p_n\}$ met voor elk project $p_a$ een starttijd $rs_a$, een deadline $dl_a$ en een verzameling activiteiten $V_a = \{v_{a,1},\dots ,v_{a,m}\}$ met voor elke activiteit $v_{a,b}$ een tijdsduur $d_{a,b}$. Daarnaast een verzameling van voorrangsrelaties $E \subseteq V \times V = \{(v_{a,b},v_{c,d}) | v_{a,b} \in V_a \wedge v_{c,d} \in V_c \wedge p_a,p_c \in P \}$, een verzameling van $w$ resources $R = \{r_1, \dots ,r_w\}$ met voor elke resource $r_i$ een eindige capaciteit $cap(r_i)$, en voor elke activiteit $v_{a,b} \in \bigcup_{\{p_a \in P\}} V_a$ een hoeveelheid van resource $r_k \in R$ die nodig is, $req(v_{a,b},r_k)$.

\textbf{Vind:}\\
Een doenlijk schema $S = \{s_1,\dots ,s_m\}$ bestaande uit starttijden $s_{a,b}$ voor elke activiteit $v_{a,b} \in \bigcup_{\{p_a \in P\}} V_a$, zodat $rs_a \leq s_{a,b} \wedge s_{a,b} + d_{a,b} \leq dl_a$, waarbij voor elke voorrangsrelatie $(v_{a,b},v_{c,d}) \in E$ geldt dat $s_{a,b} + d_{a,b} \leq s_{c,d}$. Bovendien mag geen enkele resource capaciteit overschreden worden, wat inhoudt dat $\forall r_i \in R$ en $\forall t \in \mathbb{R}$ geldt dat $\Sigma _{\{v_{a,b} \in \bigcup_{\{p_a \in P\}} V_a | s_{a,b} \leq t \leq s_{a,b} + d_{a,b}\}} req(v_{a,b},r_i) \leq cap(r_i)$.

\subsection{Flexibiliteit}
Omdat de huidige software al een oplossing voor het RCPSP kan vinden, is aan ons de taak om deze oplossing flexibeler te maken. Daarvoor moet dus eerst de flexibiliteit van een schema gedefini\"eerd worden. Hiervoor zal de flexibiliteitsmaat van Wilson \emph{et al.} \cite{wilson2013flexibility} gebruikt worden, omdat deze maat er ook rekening mee houdt dat een schema minder flexibel wordt door het toevoegen van voorrangsrelaties. Om deze te berekenen, moet voor elke activiteit $v_{a,b}$ een interval $[l_v,u_v]$ berekend worden, zodat elke activiteit in zijn eigen interval verschoven kan worden, zonder dat daardoor andere activiteiten verplaatst hoeven te worden. Dit houdt dus in dat de verzameling van intervallen $I_S = \{I_v = [l_v,u_v] | v \in \bigcup_{p_a \in P} V_a\}$ voldoet desda voor elke $v \in \bigcup_{p_a \in P} V_a$ en voor elke $t_v \in [l_v,u,v]$, een toewijzijng van starttijd $t_v$ aan activiteit $v$ een consistent schema oplevert.

...

\subsection{Oplossing}
In de bestaande software was al een algoritme ge\"implementeerd dat een doenlijk schema kan vinden door middel van het ESTA$^+$ algoritme \cite{ronaldevers2010}.
Dit algoritme lost het RCPSP op door het vinden en oplossen van \emph{contention peaks}, plekken in het resource profiel waar er meer resource units gebruikt worden dan er beschikbaar zijn. Deze worden veroorzaakt doordat er te veel activeiten die dezelfde resource gebruiken tegelijk uitgevoerd worden en kunnen opgelost worden door tussen minstens 1 paar van deze activiteiten een voorrangsrelatie toe te voegen. Het $ESTA^+$ algoritme levert als oplossing voor elke activiteit een starttijd, zodat het gehele schema consistent is. Als er met activiteiten geschoven wordt, kan het schema echter nog wel inconsistent worden.

