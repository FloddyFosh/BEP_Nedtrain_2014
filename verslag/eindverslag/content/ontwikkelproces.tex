\section{Ontwikkelproces}
Dit hoofdstuk beschrijft hoe het ontwikkelproces van het project is verlopen. Er wordt verteld welke ontwikkelmethoden en wat voor hulpmiddelen er gebruikt zijn tijdens dit project en wat onze ervaringen daarbij waren. Het hoofdstuk wordt afgesloten met feedback van de Software Improvement Group en wat er met die feedback gedaan is. 

\subsection{Ontwikkelmethode}
Gedurende het hele project is er zo veel mogelijk gebruik gemaakt van de Scrum principes, zoals beschreven in \emph{The Scrum Guide} \cite{schwaber2011}. De implementatiefase is in 6 sprints verdeeld van elk een week. Voorafgaand aan elke week is er vastgesteld wat de taken en doelen voor die week zijn.  Meestal waren features aan het eind van een sprint geschikt voor een mogelijke demo, maar zat er nog wel een aantal bugs in. Het meest voorkomende probleem was dat een feature aan het einde van de sprint nog niet werkte op een Windows systeem. Voor elke sprint zal een korte beschrijving gegeven worden en een kleine terugblik op hoe de sprint is verlopen en wat onze ervaringen waren.

\subsubsection{Sprint 1}
Het doel van de eerste sprint was om het chaining algoritme te implementeren en bekend te raken met de bestaande software. Daarnaast was een begin maken van het porten van de NedTrain Planner naar Windows 7 ook een doel in de eerste sprint, aangezien tijdens de onderzoeksfase gebleken was dat dit in een redelijke tijd uitgevoerd zou moeten kunnen.

\textbf{Terugblik} \\
We zijn erg tevreden over het verloop van de eerste sprint. Het porten naar Windows 7 liep met een paar kleine tegenvallers redelijk vlot. Naast het porten naar Windows 7 is het ook in deze sprint gelukt om de versie van Qt te upgraden naar versie 5.2.1. De basis van ons chaining algoritme werkt, maar de samenwerking tussen de GUI en de solver loopt nog niet zoals gewenst. Er is zelfs ook al een begin gemaakt aan de LP solver, een doel dat voor de tweede sprint gepland stond. 

\subsubsection{Sprint 2}
Het voornaamste doel van de tweede sprint is de COIN-OR LP solver te laten samenwerken met onze applicatie. Daarnaast was het laten zien van aparte chains met daarbij welke resources er door deze chain gebruikt worden ook een doel voor deze sprint. 

\textbf{Terugblik} \\
In deze sprint hebben we een aantal tegenvallers gehad. Zo hadden we last van een memory leak, wat redelijk veel tijd kostte om op te lossen. Bovendien moest de bestaande architectuur voor het laten zien van chains grotendeels aangepast worden. Een tweede tegenvaller was het updaten van de software op de Jenkins-server. Aangezien de tools ge\"upgrade zijn naar Qt versie 5.x, moet op de server Qt ook worden ge\"upgraded. Dit ging niet meteen de eerste keer goed, waarbij uiteindelijk is overgegaan tot een volledige herinstallatie. Dit heeft als gevolg dat een deel van de eerste commits mist in de continuous integration grafiek. In deze sprint is er ook nog verder gewerkt aan het porten van de applicatie naar Windows. We merkten dat kleine aanpassingen in de code om features te laten werken voor Linux, zorgde voor nieuwe Windows gespecificeerde bugs. Hierdoor duurde het implementeren van nieuwe features langer dan normaal, omdat de applicatie voor beide systemen moet werken.

\subsubsection{Sprint 3}
In deze sprint stond een demo geven aan de opdrachtgevers op het programma. Hiermee kon er gecontroleerd worden of de tot dan toe ge\"implementeerde features naar wens waren volgens de opdrachtgevers. Hierdoor was het mogelijk om nog het \'e\'en en ander aan te passen in deze en volgende sprints. Verder was deze week beschikbaar gemaakt voor uitloop en het verfijnen van de gemaakte features.

\textbf{Terugblik} \\
Het is in deze sprint gelukt om per chain te laten zien welke resources er door de activiteiten in deze chain gebruikt worden. Elke chain kan apart op een frame getoond worden, waarbij de resource units die door deze chain gebruikt zijn blauw gekleurd worden. De resource units die door eerdere chains van deze resource gebruikt zijn, zijn zwart gekleurd. Dit is tijdens de demo gedemonstreerd. De feedback die hierover gegeven was, was dat er niet heel makkelijk gezien kon worden welke taken bij een bepaalde resource unit hoorde. Om dit duidelijker te maken, zou een aparte view gemaakt kunnen worden. Hierin is echter minder makkelijk te zien hoeveel resources er op een bepaald tijdstip gebruikt worden.

De CLP solver is in deze sprint ook veel verder gevorderd. Er bestaat niet meer een aparte binary voor de CLP solver, maar deze is ge\"integreerd in de binary van de chaining solver. Er kan een willekeurige LP instantie als input gegeven worden en deze kan door de solver opgelost worden. Wat nu nog overblijft is het transformeren van een RCPSP instantie naar een LP instantie, zodat deze opgelost kan worden.

\subsubsection{Sprint 4}
In deze sprint was het doel om de flexibiliteitsintervallen, die worden berekend met behulp van de LP-solver, door te geven aan de gebruikersinterface. Ook was het belangrijk om dit op een goede manier weer te geven, zodat de gebruiker deze informatie op een juiste manier kan interpreteren. Tenslotte wilden we de tool zo compileren, dat de gebruiker het gemakkelijk kan installeren. Hiervoor moest de tool statisch gelinkt worden met de gebruikte libraries. Op deze manier kan de applicatie uitgevoerd worden, zonder dat er nog andere software ge\"installeerd hoeft te worden.

\textbf{Terugblik} \\
Het is ons gelukt om in deze sprint de flexibiliteitsintervallen weer te geven op het scherm, maar de gebruiker kan dit nog niet aan- en uitzetten. Het verder doorontwikkelen van de features rondom de flexibiliteitsintervallen krijgt een hoge prioriteit in de volgende sprint. De NedTrain Planner kan nu zeer gemakkelijk ge\"installeerd worden op Windows 7, maar voor systemen met Linux werkt dit helaas nog niet. Het statisch linken van de applicatie is tijdrovend, aangezien de applicatie van veel dingen afhankelijk is. 

\subsubsection{Sprint 5}
In deze sprint was het doel om de feature van het weergeven van de flexibiliteit af te maken en te testen. Aan het einde van deze sprint moest de code worden opgestuurd naar SIG en moest er een eerste versie van het eindverslag af zijn. 

\textbf{Terugblik} \\
We hebben in deze sprint veel tijd moeten besteden aan het verslag, maar we hebben gelukkig ook tijd kunnen besteden aan het verder door ontwikkelen van de NedTrain Planner. In deze sprint hebben we de code kwaliteit verbeterd en veel bugs ontdekt die de vorige projecten hebben achter gelaten. De meeste bugs zijn in deze sprint verholpen.

\subsubsection{Sprint 6}
Aan het begin van deze sprint werd er weer een demo gegeven, zodat de opdrachtgever kon zien hoe het er met de product voor staat. De feedback die verkregen waren tijdens de demo zijn als doelen opgesteld voor deze sprint. Daarnaast moest er in deze sprint ook gekeken worden naar de effici\"entie van de ge\"implementeerde algoritmes, aangezien bij grote instanties de interface vastliep.

\textbf{Terugblik} \\
Na de demo is er besloten om nog \'e\'en laatste feature te implementeren, omdat dit voor de opdrachtgever een vrij hoge prioriteit had. Dit is de rooster feature, die de werking van het chaining algoritme duidelijker maakt. Daarnaast is er duidelijker gemaakt welke resources aangepast worden in een stap van de solver, door de desbetreffende resources te highlighten. Het vastlopen van de interface is ook verholpen in deze sprint. De algoritmes en de communicatie tussen de solver en de interface zijn effici\"enter gemaakt. Verder zijn er weer behoorlijk wat bugs opgelost en is het verslag afgemaakt. 

\subsection{Hulpmiddelen}
Zoals beschreven in het Plan van Aanpak (Bijlage \ref{app:B}) en het Ori\"entatieverslag (Bijlage \ref{app:C}) is er voor een aantal hulpmiddelen gekozen om te gebruiken tijdens het project. In deze paragraaft wordt onze ervaring van het gebruik van deze hulpmiddelen besproken, maar ook een aantal resultaten daarvan. 

\subsubsection{Versiebeheer}
\label{subsec:versiebeheer}
Als versiebeheersysteem is voor dit project een Git repository gebruikt op de website \href{http://bitbucket.com}{Bitbucket.com}. Er was hiervoor gekozen omdat de projectleden het meest bekend waren met Git. Ondanks dat is er nog veel bijgeleerd en gaat het gebruik ons steeds makkelijker af. Het is gelukt om altijd een werkende master branch te hebben. Dit heeft als grote voordeel dat er op elk moment tijdens het ontwikkelproces een demo gehouden kan worden. Ook is dit belangrijk om de tests op de continuous intregration server te laten slagen. Doordat de tool moest blijven werken op zowel Windows 7 als Linux, werden nieuwe features relatief laat aan de master branch toegevoegd. Vaak werd een nieuwe feature op een systeem met Linux ge\"implementeerd en pas als het af was op een systeem met Windows 7 getest, om daar vervolgens de problemen te verhelpen.

\subsubsection{Continuous Integration}
Tijdens het project was het plan om continuous integration toe te passen door gebruik te maken van een Jenkins server. Deze server werd zelfstandig beheerd en stond fysiek bij \'e\'en van de projectleden thuis. Het kostte erg veel tijd om alle software, die nodig was voor het compileren van dit project, te installeren. Zoals vermeld staat in paragraaf '\nameref{subsec:versiebeheer}', is er relatief laat nieuwe features toegevoegd aan de master branch. Dit heeft als gevolg dat de master branch weinig verandert en het daardoor minder nuttig is om elke dag de applicatie te compileren en te testen. Ook zijn er problemen ontstaan bij het upgraden naar Qt versie 5. Het upgraden van de software op de server ging gepaard met veel problemen en er is uiteindelijk overgegaan tot herinstallatie van de server. In sprint 5 zijn er wederom problemen ontstaan toen de server een keer opnieuw werd opgestart, waardoor de build geschiedenis kwijt is geraakt. Al met al heeft het toepassen van continuous integration veel tijd gekost en weinig opgeleverd. 

\subsubsection{Google Test}
Het project beschikte aan het begin van het project al over een flinke hoeveelheid tests, maar er waren nog veel klassen waar helemaal geen tests voor waren gemaakt door eerdere projecten. Voor deze klassen en voor nieuwe features zijn door ons tests gemaakt. De solver beschikte over helemaal geen tests. Een uitgebreide testsuite is ook belangrijk voor de opdrachtgever. Zo kunnen volgende ontwikkelaars gemakkelijk op dit project voortbouwen zonder ongemerkt onderdelen kapot te maken. 

Alle tests die gemaakt zijn, maken gebruiken van het Google Test framework. Dit was erg prettig in het gebruik en het uitbreiden van de testsuite ging redelijk eenvoudig. Er is besloten om voor de solver een aparte testsuite te maken en deze niet te integreren met de bestaande testsuite voor de interface. Dit heeft als voordeel dat de testsuites net als de interface en solver zelf apart gebruikt kunnen worden. Voor de solver zijn er $42$ tests gemaakt. 

Om de grootte van de testsuite te controleren, is er gebruik gemaakt van de \emph{Code Coverage Tool} \texttt{gcovr}. Deze tool geeft per bestand aan hoeveel regels code en branches er zijn uitgevoerd door de testsuite. Deze tool stimuleerde ons om meer testcases te schrijven, om daarmee een hogere dekking te bereiken. De resultaten van de analyse van deze tool zijn te vinden in Tabel \ref{tbl:covr-solver}. Het percentage branches dat wordt getest door de testsuite is met een gemiddelde van $56,1\%$ aan de lage kant. Het percentage van regels code dat wordt getest door de testsuite is met een gemiddelde van $76,8\%$ wel redelijk.

\begin{table}[H]
    \centering
    \begin{tabular}{| l | r | r |}
        \hline
        Bestand & \midden{Regels $(\%)$} & \midden{Branches $(\%)$} \\
        \hline
        \texttt{chaining.cpp}    & $87,2$   & $58,1$ \\ 
        \texttt{constraints.cpp} & $100,0$  & $56,6$ \\
        \texttt{esta\_plus.cpp}  & $69,3$   & $56,0$ \\
        \texttt{exceptions.cpp}  & $62,5$   & $50,0$ \\
        \texttt{flexibility.cpp} & $99,0$   & $53,2$ \\
        \texttt{heap.cpp}        & $54,7$   & $58,3$ \\
        \texttt{output.cpp}      & $68,8$   & $50,0$ \\
        \texttt{solve.cpp}       & $65,2$   & $50,0$ \\
        \texttt{stjn.cpp}        & $68,9$   & $57,8$ \\
        \texttt{timing.cpp}      & $79,6$   & $63,6$ \\
        \texttt{tmsp.cpp}        & $95,5$   & $55,9$ \\
        \hline
        \hline
        Gemiddelde               & $76,8$   & $56,1$ \\
        \hline
    \end{tabular}
    \caption{Code coverage van Solver}
    \label{tbl:covr-solver}
\end{table}

Ook voor de NedTrain Planner is er een code coverage analyse gedaan. De resultaten daarvan staan in Tabel \ref{tbl:covr-planner}. Vooral de mappen \emph{controller}, \emph{widgets} en \emph{dialogs} bevatten veel code met een lage dekking. Dit komt doordat het testen van interfaces niet gemakkelijk is en veel tijd kost, zo stelt ook de vorige groep ontwikkelaars \cite{bep2012nedtrain}. Doordat de solver nog geen testsuite had en daar ook veel code bij is gemaakt tijdens dit project, is er vooral gefocust op een goede testsuite voor de solver, dit ten nadele van de testsuite voor de interface. 

\begin{table}[H]
    \centering
    \begin{tabular}{| l | r | r |}
        \hline
        Bestand & \midden{Regels $(\%)$} & \midden{Methodes $(\%)$} \\
        \hline
        \texttt{controller}     & $29,4$ & $40,2$ \\
        \texttt{data}           & $37,3$ & $47,7$ \\
        \texttt{model}          & $63,1$ & $65,7$ \\
        \texttt{solve}          & $45,1$ & $54,3$ \\
        \texttt{util}           & $60,2$ & $62,2$ \\
        \texttt{widgets}        & $46,3$ & $38,1$ \\
        \texttt{widgets/dialogs} & $6,9$ & $11,4$ \\
        \hline \hline
        Gemiddelde              & $41,8$ & $41,0$ \\
        \hline
    \end{tabular}
    \caption{Code coverage van NedTrain Planner}
    \label{tbl:covr-planner}
\end{table}

\subsubsection{\cpp\ en Qt}
Voor de ontwikkeling van de applicatie werd er gebruik gemaakt van \cpp\ in combinatie met het Qt framework. Wij hadden vrij weinig ervaring met \cpp\, maar doordat deze programmeertaal gebruikt moest worden tijdens dit project is er veel bijgeleerd over \cpp\. Het debuggen van \cpp -code werd wel lastiger bevonden dan bijvoorbeeld bij een programmeertaal als JAVA. Vooral \emph{Segmentation faults} kwamen vaak voor, waarbij er weinig informatie werd gegeven over wat er precies fout ging. Ondanks de moeilijkheden zouden wij \cpp\ wel willen gebruiken bij volgende projecten, vooral als een goede performance een eis van de opdrachtgever is. 

Niemand van de projectleden had ooit eerder met Qt gewerkt, maar dit zouden we zeker vaker willen gaan gebruiken. Het is prettig werken met Qt en het levert een grafisch mooie gebruikersinterface op. Het was ook nuttig dat de applicatie voor een gedeelte was ge\"implementeerd, omdat dan sneller duidelijk was hoe bepaalde functies werken in Qt. Aan de andere kant was het ontdekken en verhelpen van bugs vervelend, omdat de code al een redelijke omvang had en voor ons onbekend was.

\subsection{Software Improvement Group}
Aan het eind van sprint 5 is al onze code opgestuurd naar de Software Improvement Group, die op de code feedback en een beoordeling van 1 tot 5 sterren geeft. De code wordt op de volgende onderdelen beoordeeld \cite{sigmanual}:
\begin{itemize}
\item \textbf{Volume} - Hoe meer regels code een applicatie bevat, hoe moeilijker het wordt om deze te onderhouden.
\item \textbf{Duplication} - Het kopi\"eren van code moet zo veel mogelijk vermeden worden.
\item \textbf{Unit size} - Het grootste deel van de applicatie moet bestaan uit units van maximaal 20 regels.
\item \textbf{Unit complexity} - De cyclomatische complexiteit, gemeten d.m.v. het \emph{McCabe complexity number}, moet voor het grootste deel van de code niet hoger zijn dan 5.
\item \textbf{Unit interfacing} - Het meegeven van meer dan 2 parameters moet zo veel mogelijk vermeden worden.
\item \textbf{Module coupling} - Het sterk gekoppeld zijn van verschillende groepen units moet vermeden worden, omdat dit de software moeilijker te onderhouden maakt.
\item \textbf{Component balance} - Alle componenten moeten ongeveer even groot zijn. Dit onderdeel wordt beoordeeld d.m.v. de \emph{adjusted Gini coefficient}.
\item \textbf{Component independence} - Er moet gestreefd worden naar zo veel mogelijk componenten die niet aangeroepen worden door componenten van andere modules. Alleen interface klassen zouden de communicatie tussen verschillende modules moeten regelen.
\end{itemize}

In de volgende paragrafen zal het ontvangen feedback van SIG en de handelingen die zijn uitgevoerd door ons op basis van de feedback gegeven worden.

\subsubsection{Feedback SIG}
Van de code die op vrijdag 13 juni 2014 is opgestuurd, is de volgende feedback gekregen.

\begin{tabular}{p{0.5cm} | p{\textwidth - 2cm} |}
\cline{2-2}
 & \\ & \setlength{\parskip}{5pt}
De code van het systeem scoort bijna 4 sterren op ons onderhoudbaarheidsmodel, wat betekent dat de code bovengemiddeld onderhoudbaar is. De hoogste score is niet behaald door een lagere score voor Module Coupling, Unit Size en Unit Complexity.

Voor Module Coupling wordt er gekeken naar het percentage van de code wat relatief vaak wordt aangeroepen. Normaal gesproken zorgt code die vaak aangeroepen wordt voor een minder stabiel systeem omdat veranderingen binnen dit type code kan leiden tot aanpassingen op veel verschillende plaatsen. In dit systeem wordt bijvoorbeeld de relatief grote file 'instance\_misc' op ruim $160$ verschillende plaatsen gebruikt. Een ander voorbeeld is 'instance\_manip.cpp', $1$ van de grootste files in het systeem welke op ruim $60$ plaatsen gebruikt wordt. Het lijkt erop dat deze files verschillende functionaliteiten bevatten, daarnaast is het uit de naamgeving niet duidelijk welke functionaliteit waar ge√Ømplementeerd zou moeten zijn. Om zowel de grootte als het aantal aanroepen te verminderen zouden deze functionaliteiten gescheiden kunnen worden, wat er ook toe zou leiden dat de afzonderlijke functionaliteiten makkelijker te begrijpen, te testen en daardoor eenvoudiger te onderhouden worden.

Voor Unit Size wordt er gekeken naar het percentage code dat bovengemiddeld lang is. Het opsplitsen van dit soort methodes in kleinere stukken zorgt ervoor dat elk onderdeel makkelijker te begrijpen, te testen en daardoor eenvoudiger te onderhouden wordt. Binnen de langere methodes in dit systeem, zoals bijvoorbeeld de 'esta\_plus'-methode, zijn aparte stukken functionaliteit te vinden welke ge-refactored kunnen worden naar aparte methodes. De body van condities of de 'cleanup' code zijn hier voorbeelden van. Het is aan te raden kritisch te kijken naar de langere methodes binnen dit systeem en deze waar mogelijk op te splitsen.

Voor Unit Complexity wordt er gekeken naar het percentage code dat bovengemiddeld complex is. Ook hier geldt dat het opsplitsen van dit soort methodes in kleinere stukken ervoor zorgt dat elk onderdeel makkelijker te begrijpen, makkelijker te testen en daardoor eenvoudiger te onderhouden wordt. In dit geval komen de meest complexe methoden ook naar voren als de langste methoden, waardoor het oplossen van het eerste probleem ook dit probleem zal verhelpen.

Over het algemeen scoort de code bovengemiddeld, hopelijk lukt het om dit niveau te behouden tijdens de rest van de ontwikkelfase. De aanwezigheid van test-code is in ieder geval veelbelovend, hopelijk zal het volume van de test-code ook groeien op het moment dat er nieuwe functionaliteit toegevoegd wordt. 

\hfill Software Improvement Group \\
\cline{2-2}
\end{tabular}

\subsubsection{Verbeteringen}
Aan de hand van de feedback van SIG zijn er vooral aanpassingen gedaan aan code van vorige projecten. Zo zijn onder andere de lange en complexe methodes in \texttt{esta\_plus.cpp} en \texttt{solver.cpp} opgegedeeld in meerdere methodes. 

In de code van de applicatie zijn ook meerdere methodes opgesplitst. Zo is er nu voor elke klasse die een grafisch venster aanmaakt een methode toegevoegd die de layout van het venster opbouwt, in plaats van dit allemaal in de al behoorlijk lange constructor te doen. Alhoewel deze methode nog steeds bovengemiddeld lang is voor sommige klassen, is deze niet verder opgesplitst, aangezien dit niet de leesbaarheid van de code ten goede zou komen. Deze code is goed uitgelijnd en het is meteen duidelijk wat het doet.

Aan 'Module Coupling' is vrijwel niets gedaan, omdat voor het verlagen van de 'Module Coupling' grootschalige aanpassingen gedaan moesten worden aan het project en hiervoor niet meer genoeg tijd beschikbaar was. De reden dat methodes in \texttt{intance\_manip.cpp} en \texttt{instance\_misc.cpp} veel worden aangeroepen, komt doordat deze klasse alle informatie bewaart van een instantie. Als in de interface een instantie geopend wordt, moet alle informatie over die instantie worden bijgehouden. Aangezien een instantie \'e\'en ding is, is het ook niet logisch om deze nog verder op te delen. Het is al opgedeeld in twee bestanden, om de coupling te verlagen.
