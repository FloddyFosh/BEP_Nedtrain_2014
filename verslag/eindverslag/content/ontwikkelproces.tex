\section{Ontwikkelproces}
\subsection{Ontwikkelmethode}
Tijdens de ontwikkeling van van de NedTrain Planner en solver hebben wij zoveel mogelijk gebruik gemaakt van de scrum principes. Meestal waren features aan het eind van een sprint geschikt voor een mogelijke demo, maar zaten er nog wel een aantal bugs in. Het meest voorkomende probleem was dat een feature aan het einde van de sprint nog niet werkte op een Windows computer.

\subsubsection{Sprint 1}
Het doel van de eerste sprint was om chaining te implementeren. Tijdens de onderzoeksfase hebben we gezien dat het beschikbaar maken voor Windows 7 waarschijnlijk goed te doen is in de tijd die we daarvoor hebben. Het beschikbaar maken voor Windows 7 was daarom ook een doel in de eerste sprint. 

\textbf{Terugblik} \\
We zijn er tevreden over het verloop van de eerste sprint. Het porten naar Windows 7 liep met een paar kleine tegenvallers redelijk vlot. Naast het poorten naar Windows 7 is het ook in deze sprint gelukt om de versie van Qt te upgraden naar versie 5.2.1. De basis van ons chaining algoritme werkt, maar de samenwerking tussen GUI en Solver loopt nog niet zoals gewenst. Er is zelf ook al een begin gemaakt aan de LP Solver, een doel dat voor de twee sprint gepland stond. 

\subsubsection{Sprint 2}
Het voornaamste doel van de tweede sprint is de COIN-OR LP solver te laten samenwerken met onze applicatie. Daarnaast is er gewerkt aan het laten zien van aparte chains met daarbij welke resources er door deze chain gebruikt worden. 

\textbf{Terugblik} \\
In deze sprint hebben we een aantal tegenvallers gehad. Zo hadden we last van een memory leak, wat redelijk veel tijd kostte om op te lossen. Bovendien moest de bestaande architectuur voor het laten zien van chains vrij veel aangepast worden. Een tweede tegenvaller was het updaten van de software op de Jenkins-server. Aangezien we de tools hebben ge\"upgrade naar Qt versie 5.x, moet op de server Qt ook worden ge\"upgraded. Dit ging niet meteen de eerste keer goed, waarbij uiteindelijk is overgegaan tot een volledige herinstallatie. Dit heeft als gevolg dat we een deel van de eerste commits missen in de continuous integration grafiek.

\subsubsection{Sprint 3}
In deze sprint zullen we een demo geven aan onze opdrachtgevers. Hiermee kunnen we controleren of wat wij hebben gemaakt de opdrachtgevers ook echt willen. We kunnen dan nog het \'e\'en en ander aanpassen in deze en volgende sprints.

\textbf{Terugblik} \\
Het is in deze sprint gelukt om per chain te laten zien welke resources er door de activities in deze chain gebruikt worden. Elke chain kan apart op een frame getoond worden, waarbij de resource units die door deze chain gebruikt zijn, blauw gekleurd worden. De resource units die door eerdere chains van deze resource gebruikt zijn, zijn zwart gekleurd. Dit hebben we tijdens de demo laten zien. De feedback die hierover gegeven was, was dat er niet heel makkelijk gezien kan worden welke taken bij een bepaalde resource unit, bijvoorbeeld een monteur, horen. Om dit duidelijker te maken, zou een aparte view gemaakt kunnen worden. Hierin is echter minder makkelijk te zien hoeveel resources er op een bepaald tijdstip gebruikt worden.

De CLP solver is in deze sprint ook veel verder gevorderd. Er bestaat niet meer een aparte binary voor de CLP solver, maar deze is ge\"integreerd in de binary van de chaining solver. Er kan een willekeurige LP instantie als input gegeven worden en deze kan door de solver opgelost worden. Wat nu nog overblijft is het transformeren van een RCPSP instantie naar een LP instantie, zodat deze opgelost kan worden.

\subsubsection{Sprint 4}
In deze sprint hebben we als doel om de flexibiliteitsintervallen, die worden berekend m.b.v. de LP-solver, door te geven aan de gebruikersinterface. Ook is het belangrijk om dit op een goede manier weer te geven, zodat de gebruiker deze informatie op een juiste manier kan interpreteren. Tenslotte willen we de tool zo compileren, dat de gebruiker het gemakkelijk kan installeren. Hiervoor moet de tool statisch gelinkt worden met de gebruikte libraries. Op deze manier kan de applicatie uitgevoerd worden, zonder dat er nog andere software ge\"installeerd moet worden.

\textbf{Terugblik} \\
Het is ons gelukt om in deze sprint de flexibiliteitsintervallen weer tegeven op het scherm, maar de gebruiker kan dit nog niet aan- en uitzetten. Het verder doorontwikkelen van de features rondom de flexibiliteitsintervallen krijgt een hoge prioriteit in de volgende sprint. De NedTrain Planner kan nu zeer gemakkelijk ge\"installeerd worden op Windows 7, maar voor computers met Linux werkt dit helaas nog niet. 

\subsubsection{Sprint 5}
In deze sprint is het belangrijk de feature van het weergeven van de flexibiliteit af te maken en te testen. Aan het einde van deze sprint moet de code worden opgestuurd naar SIG en moet er een eerste versie van het eindverslag af zijn. 

\textbf{Terugblik} \\
We hebben deze sprint veel tijd moeten besteden aan het verslag, maar we hebben gelukkig ook tijd kunnen besteden aan het verder door ontwikkelen van de NedTrain Planner. In deze sprint hebben we de code kwaliteit verbeterd en bugs ontdekt de vorige groep heeft achter gelaten. Deze bugs hebben we ook meteen weten te verhelpen.

\subsubsection{Sprint 6}
Aan het begin van deze sprint gaan we weer een demo doen, zodat de klant kan zien waar het product nu staat. 

\textbf{Terugblik} \\
TODO: 

\subsection{Hulpmiddelen}
\subsubsection{Versiebeheer}
\label{subsec:versiebeheer}
Als versiebeheersysteem is voor dit project een Git repository gebruikt op de website \href{http://bitbucket.com}{Bitbucket.com}. Hiervoor hadden wij gekozen, omdat wij het meest bekend zijn met Git. Toch hebben wij nog veel bijgeleerd en gaat het gebruik ons steeds makkelijker af. Het is ons gelukt om altijd een werkende master branch te hebben. Dit heeft als grote voordeel dat er op elk moment tijdens het ontwikkelproces een demo gehouden kan worden. Ook is dit belangrijk om de tests op de continuous intregration server te laten slagen. Doordat de tool moet blijven werken op zowel Windows 7 als Linux, werden nieuwe features relatief laat aan de master branch toegevoegd. Vaak ontwikkelden we een nieuwe feature op een computer met Ubuntu en gingen pas als het af is de problemen op Windows 7 verhelpen.

\subsubsection{Continuous Integration}
Wij hebben continuous integration willen toepassen door gebruik te maken van een Jenkins server. Deze server werd door onszelf beheerd en stond fysiek bij \'e\'en van de projectleden thuis. Het heeft erg veel tijd gekost om alle software, die nodig is voor het compileren van dit project, te installeren. Zoals vermeld staat in sectie '\nameref{subsec:versiebeheer}', hebben we relatief laat nieuwe features toegevoegd aan de master branch. Dit heeft als gevolg dat de master branch weinig verandert en het daardoor weinig zin heeft om elke dag te builden. Ook zijn er problemen ontstaan bij het upgraden naar Qt versie 5. Het upgraden van de software op de server ging gepaard met veel problemen en er is uiteindelijk overgegaan tot herinstallatie van de server. In sprint 5 zijn er wederom problemen ontstaan toen de server een keer opnieuw werd opgestart, hierdoor zijn wij de build geschiedenis kwijtgeraakt. Al met al heeft het toepassen van continuous integration veel tijd gekost en weinig opgeleverd. 

\subsection{Software Improvement Group}

Aan het eind van sprint 5 is al onze code opgestuurd naar de Software Improvement Group, die op de code feedback en een beoordeling van 1 tot 5 sterren zal geven. De code wordt op de volgende onderdelen beoordeeld \cite{sigmanual}:
\begin{itemize}
\item \textbf{Volume} - Hoe meer regels code een applicatie bevat, hoe moeilijker het wordt om deze te onderhouden.
\item \textbf{Duplication} - Het kopi\"eren van code moet zo veel mogelijk vermeden worden.
\item \textbf{Unit size} - Het grootste deel van de applicatie moet bestaan uit units van maximaal 20 regels.
\item \textbf{Unit complexity} - De cyclomatische complexiteit, gemeten d.m.v. het \emph{McCabe complexity number}, moet voor het grootste deel van de code niet hoger zijn dan 5.
\item \textbf{Unit interfacing} - Het meegeven van meer dan 2 parameters moet zo veel mogelijk vermeden worden.
\item \textbf{Module coupling} - Het sterk gekoppeld zijn van verschillende groepen units moet vermeden worden, omdat dit de software moeilijker te onderhouden maakt.
\item \textbf{Component balance} - Alle componenten moeten ongeveer even groot zijn. Dit onderdeel wordt beoordeeld d.m.v. de \emph{adjusted Gini coefficient}.
\item \textbf{Component independence} - Er moet gestreefd worden naar zo veel mogelijk componenten die niet aangeroepen worden door componenten van andere modules. Alleen interface klassen zouden de communicatie tussen verschillende modules moeten regelen.
\end{itemize}

Van de code die op vrijdag 13 juni is opgestuurd, is het het volgende commentaar op ontvangen.

\begin{tabular}{p{1cm} | p{\textwidth - 2cm} |}
\cline{2-2}
 & \setlength{\parskip}{5pt}
De code van het systeem scoort bijna 4 sterren op ons onderhoudbaarheidsmodel, wat betekent dat de code bovengemiddeld onderhoudbaar is. De hoogste score is niet behaald door een lagere score voor Module Coupling, Unit Size en Unit Complexity.

Voor Module Coupling wordt er gekeken naar het percentage van de code wat relatief vaak wordt aangeroepen. Normaal gesproken zorgt code die vaak aangeroepen wordt voor een minder stabiel systeem omdat veranderingen binnen dit type code kan leiden tot aanpassingen op veel verschillende plaatsen. In dit systeem wordt bijvoorbeeld de relatief grote file 'instance\_misc' op ruim $160$ verschillende plaatsen gebruikt. Een ander voorbeeld is 'instance\_manip.cpp', $1$ van de grootste files in het systeem welke op ruim $60$ plaatsen gebruikt wordt. Het lijkt erop dat deze files verschillende functionaliteiten bevatten, daarnaast is het uit de naamgeving niet duidelijk welke functionaliteit waar ge√Ømplementeerd zou moeten zijn. Om zowel de grootte als het aantal aanroepen te verminderen zouden deze functionaliteiten gescheiden kunnen worden, wat er ook toe zou leiden dat de afzonderlijke functionaliteiten makkelijker te begrijpen, te testen en daardoor eenvoudiger te onderhouden worden.

Voor Unit Size wordt er gekeken naar het percentage code dat bovengemiddeld lang is. Het opsplitsen van dit soort methodes in kleinere stukken zorgt ervoor dat elk onderdeel makkelijker te begrijpen, te testen en daardoor eenvoudiger te onderhouden wordt. Binnen de langere methodes in dit systeem, zoals bijvoorbeeld de 'esta\_plus'-methode, zijn aparte stukken functionaliteit te vinden welke ge-refactored kunnen worden naar aparte methodes. De body van condities of de 'cleanup' code zijn hier voorbeelden van. Het is aan te raden kritisch te kijken naar de langere methodes binnen dit systeem en deze waar mogelijk op te splitsen.

Voor Unit Complexity wordt er gekeken naar het percentage code dat bovengemiddeld complex is. Ook hier geldt dat het opsplitsen van dit soort methodes in kleinere stukken ervoor zorgt dat elk onderdeel makkelijker te begrijpen, makkelijker te testen en daardoor eenvoudiger te onderhouden wordt. In dit geval komen de meest complexe methoden ook naar voren als de langste methoden, waardoor het oplossen van het eerste probleem ook dit probleem zal verhelpen.

Over het algemeen scoort de code bovengemiddeld, hopelijk lukt het om dit niveau te behouden tijdens de rest van de ontwikkelfase. De aanwezigheid van test-code is in ieder geval veelbelovend, hopelijk zal het volume van de test-code ook groeien op het moment dat er nieuwe functionaliteit toegevoegd wordt. 

\hfill Software Improvement Group \\
\cline{2-2}
\end{tabular}
