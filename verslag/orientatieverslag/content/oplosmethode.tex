\section{Oplossingsmethode}
In dit hoofdstuk zal eerst het achterliggende schedulingsprobleem van de NedTrain planner gedefini\"eerd worden. 
Vervolgens komt aan bod wat voor methoden er gebruikt gaan worden om de benodigde features te implementeren, dan wat voor werkwijze er gebruikt zal worden en tenslotte wat voor hulpmiddelen hierbij nodig zijn.

\subsection{Probleem}
Het probleem dat de NedTrain planner probeert op te lossen, bestaat uit een verzameling taken, een verzameling voorrangsrelaties, een verzameling van verschillende soorten resources en voor elke resource op elk tijdstip een maximale capaciteit. Dit probleem wordt ook wel gedefini\"eerd als het \emph{Resource-constrained Scheduling Problem (RCPSP)}. 

\subsection{Oplossing}


\subsubsection*{Chaining}
Zoals eerder genoemd in paragraaf \ref{subsec:solver}, kan een schema inconsistent worden met de resources als er in de interface taken verschoven worden. Om dit probleem op te lossen, kan de \emph{chaining} methode gebruikt worden \cite{policella2007precedence}. Voor deze methode moet eerst een oplossing voor de instantie gevonden worden die resource consistent is. Daarna wordt er aan elke eenheid van een resource een zogenaamde chain van taken toegekend. Zo'n chain is een lijst van taken $a_1, \dots a_n$, waarbij voor elke taak $a_i$ geldt dat deze taak afgerond moet zijn, voordat taak $a_{i+1}$ mag beginnen. Deze voorrangsrelatie wordt ook wel genoteerd als $a_i \prec a_{i+1}$.

Omdat de chaining methode als input een consistent schema nodig heeft, kan de in paragraaf \ref{subsec:solver} genoemde solver gebruikt worden. Deze solver levert een earliest starting time oplossing, die vervolgens dus door het chaining algoritme gebruikt kan worden.


\subsubsection*{Linear Programming}
Voor het bepalen van de flexibiliteit van een oplossing, zullen we gebruik maken van de methode beschreven in \cite{wilson2013flexibility}. Dit paper beschrijft een metriek voor de flexibiliteit op basis van interval sets. Om deze flexibiliteit te maximaliseren, moet het gegeven tijdschema getransformeerd worden waarbij elk eindpunt van een interval consistent is met alle constraints. Vervolgens kan door middel van \emph{Linear Programming} de maximale interval set gevonden worden en daarmee de flexibiliteit van dit schema.

Voor het oplossen van Linear Programming problemen bestaan er al verschillende solvers. E\'en daarvan is Gurobi commercieel software pakket, dat de problemen zeer snel kan oplossen. COIN-OR LP\footnote{projects.coin-or.org/Clp}, afgekort Clp, is een open source Linear Programming solver in \cpp . We kiezen voor Clp, omdat deze software open source is, iets wat voor onze opdrachtgever aantrekkelijker is dan Gurobi, omdat daar wel een licentie voor gekocht moet worden als de 'NedTrain Planner' echt gebruikt gaat worden.

\subsection{Werkwijze}
Tijdens de ontwikkelfase gaat het team werken met scrum in wekelijkse sprints. Scrum is een framework dat gebruikt wordt om...

\subsection{Hulpmiddelen}
Als versiebeheersysteem gebruiken we BitBucket. Op deze website zijn private Git repositories gratis beschikbaar. Bij de concurrent GitHub zijn ook private Git repositories beschikbaar, maar dan moet het account wel geactiveerd worden met een TU Delft e-mailadres. Op BitBucket is dit dus eenvoudiger in te stellen. We hebben voor Git gekozen en niet voor Subversion, omdat we meer ervaring hebben met Git. BitBucket heeft ook een ingebouwd issue-trackingsysteem waarvan wij gebruik gaan maken. Dit is in Subversion minder makkelijk in te stellen.

Om ervoor te zorgen dat we altijd werkende code hebben op Bitbucket, gaan we continuous integration gebruiken. Daarvoor is een server waarop Jenkins is ge\"intalleerd erg geschikt. Stel dat we code uploaden die niet werkt, dan geeft Jenkins daarvan automatisch een melding, zodat wij de code kunnen verbeteren en we weer werkende code hebben op Bitbucket.  

Om er voor te zorgen dat onze code goed onderhoudbaar blijft, gaan we ook een stylechecker gebruiken. De stylechecker \emph{cppcheck} controleert statisch de code op fouten en geeft waarschuwingen wanneer er bijvoorbeeld variabelen worden gedeclareerd die nooit gebruikt worden. De stylechecker \emph{cpplint} controleert op de Google code guideline voor \cpp. Ook \emph{cpplint} is niet perfect, zo zeggen ze zelf, omdat het niet alle fouten ontdekt, maar wij denken dat dit wel een goede toevoeging is. We hebben ook naar de alternatieven \emph{Vera\texttt{++}} en \emph{cxxchecker}, maar deze waren niet gemakkelijk te installeren.
